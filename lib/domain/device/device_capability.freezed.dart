// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'device_capability.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$DeviceCapability {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backgroundScheduling,
    required TResult Function() audibleAlert,
    required TResult Function() vibrateAlert,
    required TResult Function() notificationAlert,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? backgroundScheduling,
    TResult? Function()? audibleAlert,
    TResult? Function()? vibrateAlert,
    TResult? Function()? notificationAlert,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backgroundScheduling,
    TResult Function()? audibleAlert,
    TResult Function()? vibrateAlert,
    TResult Function()? notificationAlert,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BackgroundSchedulingCapability value)
        backgroundScheduling,
    required TResult Function(AudibleAlertCapability value) audibleAlert,
    required TResult Function(VibrateAlertCapability value) vibrateAlert,
    required TResult Function(NotificationAlertCapability value)
        notificationAlert,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BackgroundSchedulingCapability value)?
        backgroundScheduling,
    TResult? Function(AudibleAlertCapability value)? audibleAlert,
    TResult? Function(VibrateAlertCapability value)? vibrateAlert,
    TResult? Function(NotificationAlertCapability value)? notificationAlert,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BackgroundSchedulingCapability value)?
        backgroundScheduling,
    TResult Function(AudibleAlertCapability value)? audibleAlert,
    TResult Function(VibrateAlertCapability value)? vibrateAlert,
    TResult Function(NotificationAlertCapability value)? notificationAlert,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeviceCapabilityCopyWith<$Res> {
  factory $DeviceCapabilityCopyWith(
          DeviceCapability value, $Res Function(DeviceCapability) then) =
      _$DeviceCapabilityCopyWithImpl<$Res, DeviceCapability>;
}

/// @nodoc
class _$DeviceCapabilityCopyWithImpl<$Res, $Val extends DeviceCapability>
    implements $DeviceCapabilityCopyWith<$Res> {
  _$DeviceCapabilityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$BackgroundSchedulingCapabilityCopyWith<$Res> {
  factory _$$BackgroundSchedulingCapabilityCopyWith(
          _$BackgroundSchedulingCapability value,
          $Res Function(_$BackgroundSchedulingCapability) then) =
      __$$BackgroundSchedulingCapabilityCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BackgroundSchedulingCapabilityCopyWithImpl<$Res>
    extends _$DeviceCapabilityCopyWithImpl<$Res,
        _$BackgroundSchedulingCapability>
    implements _$$BackgroundSchedulingCapabilityCopyWith<$Res> {
  __$$BackgroundSchedulingCapabilityCopyWithImpl(
      _$BackgroundSchedulingCapability _value,
      $Res Function(_$BackgroundSchedulingCapability) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BackgroundSchedulingCapability extends BackgroundSchedulingCapability
    with DiagnosticableTreeMixin {
  _$BackgroundSchedulingCapability() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DeviceCapability.backgroundScheduling()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', 'DeviceCapability.backgroundScheduling'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BackgroundSchedulingCapability);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backgroundScheduling,
    required TResult Function() audibleAlert,
    required TResult Function() vibrateAlert,
    required TResult Function() notificationAlert,
  }) {
    return backgroundScheduling();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? backgroundScheduling,
    TResult? Function()? audibleAlert,
    TResult? Function()? vibrateAlert,
    TResult? Function()? notificationAlert,
  }) {
    return backgroundScheduling?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backgroundScheduling,
    TResult Function()? audibleAlert,
    TResult Function()? vibrateAlert,
    TResult Function()? notificationAlert,
    required TResult orElse(),
  }) {
    if (backgroundScheduling != null) {
      return backgroundScheduling();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BackgroundSchedulingCapability value)
        backgroundScheduling,
    required TResult Function(AudibleAlertCapability value) audibleAlert,
    required TResult Function(VibrateAlertCapability value) vibrateAlert,
    required TResult Function(NotificationAlertCapability value)
        notificationAlert,
  }) {
    return backgroundScheduling(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BackgroundSchedulingCapability value)?
        backgroundScheduling,
    TResult? Function(AudibleAlertCapability value)? audibleAlert,
    TResult? Function(VibrateAlertCapability value)? vibrateAlert,
    TResult? Function(NotificationAlertCapability value)? notificationAlert,
  }) {
    return backgroundScheduling?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BackgroundSchedulingCapability value)?
        backgroundScheduling,
    TResult Function(AudibleAlertCapability value)? audibleAlert,
    TResult Function(VibrateAlertCapability value)? vibrateAlert,
    TResult Function(NotificationAlertCapability value)? notificationAlert,
    required TResult orElse(),
  }) {
    if (backgroundScheduling != null) {
      return backgroundScheduling(this);
    }
    return orElse();
  }
}

abstract class BackgroundSchedulingCapability extends DeviceCapability {
  factory BackgroundSchedulingCapability() = _$BackgroundSchedulingCapability;
  BackgroundSchedulingCapability._() : super._();
}

/// @nodoc
abstract class _$$AudibleAlertCapabilityCopyWith<$Res> {
  factory _$$AudibleAlertCapabilityCopyWith(_$AudibleAlertCapability value,
          $Res Function(_$AudibleAlertCapability) then) =
      __$$AudibleAlertCapabilityCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AudibleAlertCapabilityCopyWithImpl<$Res>
    extends _$DeviceCapabilityCopyWithImpl<$Res, _$AudibleAlertCapability>
    implements _$$AudibleAlertCapabilityCopyWith<$Res> {
  __$$AudibleAlertCapabilityCopyWithImpl(_$AudibleAlertCapability _value,
      $Res Function(_$AudibleAlertCapability) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AudibleAlertCapability extends AudibleAlertCapability
    with DiagnosticableTreeMixin {
  _$AudibleAlertCapability() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DeviceCapability.audibleAlert()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'DeviceCapability.audibleAlert'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AudibleAlertCapability);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backgroundScheduling,
    required TResult Function() audibleAlert,
    required TResult Function() vibrateAlert,
    required TResult Function() notificationAlert,
  }) {
    return audibleAlert();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? backgroundScheduling,
    TResult? Function()? audibleAlert,
    TResult? Function()? vibrateAlert,
    TResult? Function()? notificationAlert,
  }) {
    return audibleAlert?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backgroundScheduling,
    TResult Function()? audibleAlert,
    TResult Function()? vibrateAlert,
    TResult Function()? notificationAlert,
    required TResult orElse(),
  }) {
    if (audibleAlert != null) {
      return audibleAlert();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BackgroundSchedulingCapability value)
        backgroundScheduling,
    required TResult Function(AudibleAlertCapability value) audibleAlert,
    required TResult Function(VibrateAlertCapability value) vibrateAlert,
    required TResult Function(NotificationAlertCapability value)
        notificationAlert,
  }) {
    return audibleAlert(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BackgroundSchedulingCapability value)?
        backgroundScheduling,
    TResult? Function(AudibleAlertCapability value)? audibleAlert,
    TResult? Function(VibrateAlertCapability value)? vibrateAlert,
    TResult? Function(NotificationAlertCapability value)? notificationAlert,
  }) {
    return audibleAlert?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BackgroundSchedulingCapability value)?
        backgroundScheduling,
    TResult Function(AudibleAlertCapability value)? audibleAlert,
    TResult Function(VibrateAlertCapability value)? vibrateAlert,
    TResult Function(NotificationAlertCapability value)? notificationAlert,
    required TResult orElse(),
  }) {
    if (audibleAlert != null) {
      return audibleAlert(this);
    }
    return orElse();
  }
}

abstract class AudibleAlertCapability extends DeviceCapability {
  factory AudibleAlertCapability() = _$AudibleAlertCapability;
  AudibleAlertCapability._() : super._();
}

/// @nodoc
abstract class _$$VibrateAlertCapabilityCopyWith<$Res> {
  factory _$$VibrateAlertCapabilityCopyWith(_$VibrateAlertCapability value,
          $Res Function(_$VibrateAlertCapability) then) =
      __$$VibrateAlertCapabilityCopyWithImpl<$Res>;
}

/// @nodoc
class __$$VibrateAlertCapabilityCopyWithImpl<$Res>
    extends _$DeviceCapabilityCopyWithImpl<$Res, _$VibrateAlertCapability>
    implements _$$VibrateAlertCapabilityCopyWith<$Res> {
  __$$VibrateAlertCapabilityCopyWithImpl(_$VibrateAlertCapability _value,
      $Res Function(_$VibrateAlertCapability) _then)
      : super(_value, _then);
}

/// @nodoc

class _$VibrateAlertCapability extends VibrateAlertCapability
    with DiagnosticableTreeMixin {
  _$VibrateAlertCapability() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DeviceCapability.vibrateAlert()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'DeviceCapability.vibrateAlert'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$VibrateAlertCapability);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backgroundScheduling,
    required TResult Function() audibleAlert,
    required TResult Function() vibrateAlert,
    required TResult Function() notificationAlert,
  }) {
    return vibrateAlert();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? backgroundScheduling,
    TResult? Function()? audibleAlert,
    TResult? Function()? vibrateAlert,
    TResult? Function()? notificationAlert,
  }) {
    return vibrateAlert?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backgroundScheduling,
    TResult Function()? audibleAlert,
    TResult Function()? vibrateAlert,
    TResult Function()? notificationAlert,
    required TResult orElse(),
  }) {
    if (vibrateAlert != null) {
      return vibrateAlert();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BackgroundSchedulingCapability value)
        backgroundScheduling,
    required TResult Function(AudibleAlertCapability value) audibleAlert,
    required TResult Function(VibrateAlertCapability value) vibrateAlert,
    required TResult Function(NotificationAlertCapability value)
        notificationAlert,
  }) {
    return vibrateAlert(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BackgroundSchedulingCapability value)?
        backgroundScheduling,
    TResult? Function(AudibleAlertCapability value)? audibleAlert,
    TResult? Function(VibrateAlertCapability value)? vibrateAlert,
    TResult? Function(NotificationAlertCapability value)? notificationAlert,
  }) {
    return vibrateAlert?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BackgroundSchedulingCapability value)?
        backgroundScheduling,
    TResult Function(AudibleAlertCapability value)? audibleAlert,
    TResult Function(VibrateAlertCapability value)? vibrateAlert,
    TResult Function(NotificationAlertCapability value)? notificationAlert,
    required TResult orElse(),
  }) {
    if (vibrateAlert != null) {
      return vibrateAlert(this);
    }
    return orElse();
  }
}

abstract class VibrateAlertCapability extends DeviceCapability {
  factory VibrateAlertCapability() = _$VibrateAlertCapability;
  VibrateAlertCapability._() : super._();
}

/// @nodoc
abstract class _$$NotificationAlertCapabilityCopyWith<$Res> {
  factory _$$NotificationAlertCapabilityCopyWith(
          _$NotificationAlertCapability value,
          $Res Function(_$NotificationAlertCapability) then) =
      __$$NotificationAlertCapabilityCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationAlertCapabilityCopyWithImpl<$Res>
    extends _$DeviceCapabilityCopyWithImpl<$Res, _$NotificationAlertCapability>
    implements _$$NotificationAlertCapabilityCopyWith<$Res> {
  __$$NotificationAlertCapabilityCopyWithImpl(
      _$NotificationAlertCapability _value,
      $Res Function(_$NotificationAlertCapability) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationAlertCapability extends NotificationAlertCapability
    with DiagnosticableTreeMixin {
  _$NotificationAlertCapability() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DeviceCapability.notificationAlert()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'DeviceCapability.notificationAlert'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationAlertCapability);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() backgroundScheduling,
    required TResult Function() audibleAlert,
    required TResult Function() vibrateAlert,
    required TResult Function() notificationAlert,
  }) {
    return notificationAlert();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? backgroundScheduling,
    TResult? Function()? audibleAlert,
    TResult? Function()? vibrateAlert,
    TResult? Function()? notificationAlert,
  }) {
    return notificationAlert?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? backgroundScheduling,
    TResult Function()? audibleAlert,
    TResult Function()? vibrateAlert,
    TResult Function()? notificationAlert,
    required TResult orElse(),
  }) {
    if (notificationAlert != null) {
      return notificationAlert();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BackgroundSchedulingCapability value)
        backgroundScheduling,
    required TResult Function(AudibleAlertCapability value) audibleAlert,
    required TResult Function(VibrateAlertCapability value) vibrateAlert,
    required TResult Function(NotificationAlertCapability value)
        notificationAlert,
  }) {
    return notificationAlert(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BackgroundSchedulingCapability value)?
        backgroundScheduling,
    TResult? Function(AudibleAlertCapability value)? audibleAlert,
    TResult? Function(VibrateAlertCapability value)? vibrateAlert,
    TResult? Function(NotificationAlertCapability value)? notificationAlert,
  }) {
    return notificationAlert?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BackgroundSchedulingCapability value)?
        backgroundScheduling,
    TResult Function(AudibleAlertCapability value)? audibleAlert,
    TResult Function(VibrateAlertCapability value)? vibrateAlert,
    TResult Function(NotificationAlertCapability value)? notificationAlert,
    required TResult orElse(),
  }) {
    if (notificationAlert != null) {
      return notificationAlert(this);
    }
    return orElse();
  }
}

abstract class NotificationAlertCapability extends DeviceCapability {
  factory NotificationAlertCapability() = _$NotificationAlertCapability;
  NotificationAlertCapability._() : super._();
}
